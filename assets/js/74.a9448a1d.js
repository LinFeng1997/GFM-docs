(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{230:function(t,r,e){"use strict";e.r(r);var a=e(0),n=Object(a.a)({},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"块和内联"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#块和内联","aria-hidden":"true"}},[t._v("#")]),t._v(" 块和内联")]),t._v(" "),e("p",[t._v("我们可以将文档视为一系列"),e("a",{attrs:{href:"https://github.github.com/gfm/#blocks",target:"_blank",rel:"noopener noreferrer"}},[t._v("块"),e("OutboundLink")],1),t._v("-结构元素，如段落，块引用，列表，标题，规则和代码块。一些块（如块引用和列表项）可以包含其他块; 其他（如标题和段落）包含"),e("a",{attrs:{href:"https://github.github.com/gfm/#inline",target:"_blank",rel:"noopener noreferrer"}},[t._v("内联"),e("OutboundLink")],1),t._v("内容-文本，链接，强调文本，图像，内联代码等。")]),t._v(" "),e("h3",{attrs:{id:"优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优先级","aria-hidden":"true"}},[t._v("#")]),t._v(" 优先级")]),t._v(" "),e("p",[t._v("块结构的指示符(indicators)始终优先于内联结构的指示符。因此，举个例子，以下是包含两项的列表，而不是包含一项包含内联代码的列表：\n"),e("Example",{attrs:{index:12}})],1),t._v(" "),e("p",[t._v("这意味着解析可以分两步进行：首先，识别文档的块结构; 然后识别段落，标题和其他块结构中的文本行，作为内联结构解析。第二步需要收集有关链接引用定义的信息，这些定义仅在第一步结束时可用。注意，第一步需要按顺序处理行，但第二步可以并行化，因为一个块元素的内联解析不会影响任何其他块的内联解析。")]),t._v(" "),e("h3",{attrs:{id:"容器块和叶子块-leaf-block"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器块和叶子块-leaf-block","aria-hidden":"true"}},[t._v("#")]),t._v(" 容器块和叶子块(leaf block)")]),t._v(" "),e("p",[t._v("我们可以将块分为两种类型："),e("a",{attrs:{href:"https://github.github.com/gfm/#container-block",target:"_blank",rel:"noopener noreferrer"}},[t._v("容器块"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://github.github.com/gfm/#leaf-block",target:"_blank",rel:"noopener noreferrer"}},[t._v("叶子块"),e("OutboundLink")],1),t._v("，容器块可以包含其他块，但叶子块不能包含其他块。")])])},[],!1,null,null,null);r.default=n.exports}}]);