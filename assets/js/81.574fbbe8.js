(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{224:function(_,v,t){"use strict";t.r(v);var e=t(0),o=Object(e.a)({},function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h3",{attrs:{id:"内联结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内联结构","aria-hidden":"true"}},[_._v("#")]),_._v(" 内联结构")]),_._v(" "),t("p",[_._v("一旦解析完所有输入，将闭合所有开启的块。"),t("br"),_._v("\n然后我们“遍历树”，访问每个节点，并将段落和标题的原始字符串内容按内联解析。此时我们已经看到了所有链接引用定义，因此我们可以随时解析引用链接。")]),_._v(" "),t("pre",[t("code",[_._v('document\n  block_quote\n    paragraph\n      str "Lorem ipsum dolor"\n      softbreak\n      str "sit amet."\n    list (type=bullet tight=true bullet_char=-)\n      list_item\n        paragraph\n          str "Qui "\n          emph\n            str "quodsi iracundia"\n      list_item\n        paragraph\n          str "aliquando id"\n')])]),_._v(" "),t("p",[_._v("注意第一段中的"),t("a",{attrs:{href:"https://github.github.com/gfm/#line-ending",target:"_blank",rel:"noopener noreferrer"}},[_._v("行尾"),t("OutboundLink")],1),_._v("是如何被解析为"),t("code",[_._v("softbreak")]),_._v("的，并且第一个列表项中的星号已成为"),t("code",[_._v("emph")]),_._v("。"),t("br"),_._v("\n一个解析嵌套强调和链接的算法。迄今为止，内联解析最棘手的部分是处理强调，加强的强调，链接和图像。 这是使用以下算法完成的。"),t("br"),_._v("\n当我们解析内联碰到以下符号时")]),_._v(" "),t("ul",[t("li",[_._v("一系列 "),t("code",[_._v("*")]),_._v(" 或者 "),t("code",[_._v("_")]),_._v(" 字符,")]),_._v(" "),t("li",[_._v("一个 "),t("code",[_._v("[")]),_._v(" 或者 "),t("code",[_._v("![")])])]),_._v(" "),t("p",[_._v("我们插入一个带有这些符号作为文字内容的文本节点，然后我们将一个指向这个文本节点的指针添加到"),t("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[_._v("分隔符栈"),t("OutboundLink")],1),_._v("。"),t("br"),_._v(" "),t("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[_._v("分隔符栈"),t("OutboundLink")],1),_._v("是一个双向链表。每个元素都包含一个指向文本节点的指针，以及以下信息")]),_._v(" "),t("ul",[t("li",[_._v("分隔符的类型 ("),t("code",[_._v("[")]),_._v(", "),t("code",[_._v("![")]),_._v(", "),t("code",[_._v("*")]),_._v(", "),t("code",[_._v("_")]),_._v(")")]),_._v(" "),t("li",[_._v("分隔符的数量")]),_._v(" "),t("li",[_._v("分隔符是否启用(可以作为开启符号), 并且")]),_._v(" "),t("li",[_._v("这些分隔符是否是潜在的开始符号或者关闭符号或者两者都是(取决于何种分隔符在其前或者在其后)。")])]),_._v(" "),t("p",[_._v("当我们遇到"),t("code",[_._v("]")]),_._v(" 时，调用 "),t("em",[_._v("查找链接或图片")]),_._v(" 过程（见下文）。"),t("br"),_._v("\n当输入完成时，我们调用 "),t("em",[_._v("解析强调")]),_._v(" 过程，此时 "),t("code",[_._v("stack_bottom")]),_._v("= NULL."),t("br"),_._v("\n查找链接或图片在分隔符栈顶部开始，向后查找开启的 "),t("code",[_._v("[")]),_._v(" 或"),t("code",[_._v("![")]),_._v("分隔符。")]),_._v(" "),t("ul",[t("li",[_._v("如果找不到，则返回一个字面上的字符"),t("code",[_._v("]")])]),_._v(" "),t("li",[_._v("如果找到，但是其未启用，则从栈中删除未启用的分隔符然后返回一个字面上的字符"),t("code",[_._v("]")])]),_._v(" "),t("li",[_._v("如果找到并且其已启用，则继续解析查看是否有内联链接/图片，引用链接/图片，紧凑的的引用链接/图片，或者快捷的引用链接/图片\n"),t("ul",[t("li",[_._v("如果没有，则移除栈中的开始分隔符，并返回一个字面上的字符"),t("code",[_._v("]")])]),_._v(" "),t("li",[_._v("如果有\n"),t("ul",[t("li",[_._v("返回一个链接或图像节点，其子节点是开始分隔符指向的文本节点后的内联内容")]),_._v(" "),t("li",[_._v("在这些内联内容上运行 "),t("em",[_._v("解析强调")]),_._v(" ，将"),t("code",[_._v("[")]),_._v("作为"),t("code",[_._v("stack_bottom")])]),_._v(" "),t("li",[_._v("移除开始分隔符")]),_._v(" "),t("li",[_._v("如果我们有一个链接（且不是图像），我们还会在开始分隔符之前将所有"),t("code",[_._v("[")]),_._v("分隔符设置为未启用。（这将阻止我们在链接中获取链接。）")])])])])])]),_._v(" "),t("p",[_._v("解析强调的变量"),t("code",[_._v("stack_bottom")]),_._v("设置了一个在 "),t("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[_._v("分隔符栈"),t("OutboundLink")],1),_._v("中下行查找的下限。如果其值为 NULL，我们可以一直查到栈底，否则，我们将在"),t("code",[_._v("stack_bottom")]),_._v("之前停止。"),t("br"),_._v("\n让"),t("code",[_._v("current_position")]),_._v(" 指针指向 "),t("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[_._v("分隔符栈"),t("OutboundLink")],1),_._v("上栈底之上的元素（或者是第一个元素，如果"),t("code",[_._v("stack_bottom")]),_._v(" 值为 NULL）。"),t("br"),_._v("\n我们跟踪每个分隔符类型为（"),t("code",[_._v("*")]),_._v("，"),t("code",[_._v("_")]),_._v("）的"),t("code",[_._v("openers_bottom")]),_._v("。以及每个结束分隔符路程的长度（3 取模）。将其初始化为"),t("code",[_._v("stack_bottom")]),_._v("。"),t("br"),_._v("\n然后我们重复以下过程直到我们用完所有的闭合符号：")]),_._v(" "),t("ul",[t("li",[_._v("在分隔符堆栈中向前移动"),t("code",[_._v("current_position")]),_._v("（如果需要），直到我们找到第一个具有分隔符"),t("code",[_._v("*")]),_._v("或"),t("code",[_._v("_")]),_._v("的潜在闭合符号。（这将是距离输入开头最近的位置 – 按解析顺序的第一个。）")]),_._v(" "),t("li",[_._v("现在，回顾堆栈（保持在"),t("code",[_._v("stack_bottom")]),_._v("和此分隔符类型的"),t("code",[_._v("openers_bottom")]),_._v("之上）匹配第一个潜在的开始符号（“匹配”意味着相同的分隔符）。")]),_._v(" "),t("li",[_._v("如果找到一个：\n"),t("ul",[t("li",[_._v("探明这是强调还是加强的强调，如果开始符号和闭合符号长度都 >= 2，则是加强的强调，否则就是强调")]),_._v(" "),t("li",[_._v("在开始符号对应的文本节点之后，相应的插入一个强调或加强的强调节点")]),_._v(" "),t("li",[_._v("在分隔符栈中移除开始符号和闭合符号中间所有的分隔符")]),_._v(" "),t("li",[_._v("从开始和闭合文本节点中删除1（强调）或2（加强的强调）分隔符。 如果它们因此变为空，则删除它们并删除分隔符堆栈的相应元素。 如果关闭节点被移除，则将"),t("code",[_._v("current_position")]),_._v("重置为堆栈中的下一个元素")])])]),_._v(" "),t("li",[_._v("如果没有找到：\n"),t("ul",[t("li",[_._v("将"),t("code",[_._v("openers_bottom")]),_._v("设置为"),t("code",[_._v("current_position")]),_._v("之前的元素。（我们知道这种闭合符号并没有对应的开始符号，所以这对之后的搜索设置了一个下限。）")]),_._v(" "),t("li",[_._v("如果"),t("code",[_._v("current_position")]),_._v("处的闭合符号不是潜在的开始符号，则将其从分隔符堆栈中移除（因为我们知道它也不能作为闭合符号）")]),_._v(" "),t("li",[_._v("将"),t("code",[_._v("current_position")]),_._v("推进到堆栈中的下一个元素")])])])]),_._v(" "),t("p",[_._v("完成之后，我们从分隔符堆栈中删除"),t("code",[_._v("stack_bottom")]),_._v("上面的所有分隔符。")])])},[],!1,null,null,null);v.default=o.exports}}]);