(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{261:function(t,e,a){"use strict";a.r(e);var s=a(0),r=Object(s.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v(t._s((t.$page.frontmatter.start=338,null)))]),t._v(" "),a("h3",{attrs:{id:"code-spans"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#code-spans","aria-hidden":"true"}},[t._v("#")]),t._v(" Code spans")]),t._v(" "),a("p",[t._v("A "),a("a",{attrs:{href:"https://github.github.com/gfm/#backtick-string",target:"_blank",rel:"noopener noreferrer"}},[t._v("backtick string"),a("OutboundLink")],1),t._v(" is a string of one or more backtick characters ("),a("code",[t._v("`")]),t._v(") that is neither preceded nor followed by a backtick."),a("br"),t._v("\nA code span(@) begins with a backtick string and ends with a backtick string of equal length.  The contents of the code span are the characters between the two backtick strings, normalized in the following ways:")]),t._v(" "),a("ul",[a("li",[t._v("First, line endings are converted to spaces.")]),t._v(" "),a("li",[t._v("If the resulting string both begins "),a("em",[t._v("and")]),t._v(" ends with a space character, but does not consist entirely of space characters, a single space character is removed from the front and back.  This allows you to include code that begins or ends with backtick characters, which must be separated by whitespace from the opening or closing backtick strings.\nThis is a simple code span:")])]),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),a("p",[t._v("Here two backticks are used, because the code contains a backtick."),a("br"),t._v("\nThis example also illustrates stripping of a single leading and trailing space:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("This example shows the motivation for stripping leading and trailing spaces:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("Note that only "),a("em",[t._v("one")]),t._v(" space is stripped:\n"),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("Only [spaces], and not [unicode whitespace] in general, are stripped in this way:\n"),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("No stripping occurs if the code span contains only spaces:\n"),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.github.com/gfm/#line-ending",target:"_blank",rel:"noopener noreferrer"}},[t._v("Line endings"),a("OutboundLink")],1),t._v(" are treated like spaces:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),a("p",[t._v("Interior spaces are not collapsed:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("Note that browsers will typically collapse consecutive spaces when rendering "),a("code",[t._v("<code>")]),t._v(" elements, so it is recommended that the following CSS be used:")]),t._v(" "),a("pre",[a("code",[t._v("code{white-space: pre-wrap;}\n")])]),t._v(" "),a("p",[t._v("Note that backslash escapes do not work in code spans. All backslashes are treated literally:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("Backslash escapes are never needed, because one can always choose a string of "),a("em",[t._v("n")]),t._v(" backtick characters as delimiters, where the code does not contain any strings of exactly "),a("em",[t._v("n")]),t._v(" backtick characters.")]),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),a("p",[t._v("Code span backticks have higher precedence than any other inline constructs except HTML tags and autolinks. Thus, for example, this is not parsed as emphasized text, since the second "),a("code",[t._v("*")]),t._v(" is part of a code span:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("And this is not parsed as a link:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("Code spans, HTML tags, and autolinks have the same precedence. Thus, this is code:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("But this is an HTML tag:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("And this is code:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("But this is an autolink:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("p",[t._v("When a backtick string is not closed by a matching backtick string, we just have literal backticks:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),a("p",[t._v("The following case also illustrates the need for opening and closing backtick strings to be equal in length:"),a("br"),t._v(" "),a("Example",{attrs:{index:t.$page.frontmatter.start++}})],1)],1)},[],!1,null,null,null);e.default=r.exports}}]);