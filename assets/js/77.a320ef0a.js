(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{227:function(t,r,e){"use strict";e.r(r);var a=e(0),n=Object(a.a)({},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v(t._s((t.$page.frontmatter.start=281,null)))]),t._v(" "),e("h3",{attrs:{id:"列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#列表","aria-hidden":"true"}},[t._v("#")]),t._v(" 列表")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.github.com/gfm/#lists",target:"_blank",rel:"noopener noreferrer"}},[t._v("列表"),e("OutboundLink")],1),t._v("是一个或多个"),e("a",{attrs:{href:"https://github.github.com/gfm/#of-the-same-type",target:"_blank",rel:"noopener noreferrer"}},[t._v("相同类型"),e("OutboundLink")],1),t._v("列表项的序列，列表项可能被一行或多行空行分隔。"),e("br"),t._v(" "),e("a",{attrs:{href:"https://github.github.com/gfm/#of-the-same-type",target:"_blank",rel:"noopener noreferrer"}},[t._v("相同类型"),e("OutboundLink")],1),t._v("列表项拥有相同的"),e("a",{attrs:{href:"https://github.github.com/gfm/#list-marker",target:"_blank",rel:"noopener noreferrer"}},[t._v("列表标记"),e("OutboundLink")],1),t._v("，如果两个列表项有使用相同字符(-,+,或*)的无序列表标记或者是使用相同分隔符(「.」或「)」)的有序列表，则它们也是同一种类型。"),e("br"),t._v("\n列表的类型由其第一个列表项的列表标记决定。"),e("br"),t._v("\n一个"),e("a",{attrs:{href:"https://github.github.com/gfm/#ordered-list",target:"_blank",rel:"noopener noreferrer"}},[t._v("有序列表"),e("OutboundLink")],1),t._v("的"),e("a",{attrs:{href:"https://github.github.com/gfm/#start-number",target:"_blank",rel:"noopener noreferrer"}},[t._v("起始序号"),e("OutboundLink")],1),t._v("由其起始列表项的序号确定，忽略后面的列表项数字。"),e("br"),t._v("\n如果列表任意的组成列表项有空行分隔，或者如果其任意的组成列表项直接包含两个块级元素，并且它们之间有空行，则列表是"),e("a",{attrs:{href:"https://github.github.com/gfm/#loose",target:"_blank",rel:"noopener noreferrer"}},[t._v("稀疏"),e("OutboundLink")],1),t._v("的。否则列表是"),e("a",{attrs:{href:"https://github.github.com/gfm/#tight",target:"_blank",rel:"noopener noreferrer"}},[t._v("稠密"),e("OutboundLink")],1),t._v("的。（HTML 输出的不同之处在于稀疏列表中的段落包含在"),e("code",[t._v("<p>")]),t._v("标记中，而稠密列表中的段落则不包含在内。）"),e("br"),t._v("\n改变无序或者有序列表的分隔符会另起新列表："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),e("p",[t._v("在 CommonMark 中，段落可以中断列表，也就是说，不需要空行来分隔段落与下列列表："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[e("code",[t._v("Markdown.pl")]),t._v("不允许这么做，因为可能会因为句子中自带的数字触发列表：")]),t._v(" "),e("pre",[e("code",[t._v("The number of windows in my house is\n14.  The number of doors is 6.\n")])]),t._v(" "),e("p",[t._v("但奇怪的是，"),e("code",[t._v("Markdown.pl")]),t._v("允许块引用中断段落，即使可能适用相同的考虑因素。"),e("br"),t._v("\n在CommonMark中，我们允许列表中断段落，原因有两个。首先，新建一个没有空行的列表是很自然的并且并不罕见：")]),t._v(" "),e("pre",[e("code",[t._v("I need to buy\n- new shoes\n- a coat\n- a plane ticket\n")])]),t._v(" "),e("p",[t._v("其次，我们发现了")]),t._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://github.github.com/gfm/#principle-of-uniformity",target:"_blank",rel:"noopener noreferrer"}},[t._v("统一性原则"),e("OutboundLink")],1),t._v(": 如果一段文本有其本身的意义，那么它在容器块中将继续含有相同的含义（像在"),e("a",{attrs:{href:"https://github.github.com/gfm/#block-quotes",target:"_blank",rel:"noopener noreferrer"}},[t._v("块引用"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://github.github.com/gfm/#list-items",target:"_blank",rel:"noopener noreferrer"}},[t._v("列表项"),e("OutboundLink")],1),t._v("中那样）。")])]),t._v(" "),e("p",[t._v("(确实，"),e("a",{attrs:{href:"https://github.github.com/gfm/#list-items",target:"_blank",rel:"noopener noreferrer"}},[t._v("列表项"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://github.github.com/gfm/#block-quotes",target:"_blank",rel:"noopener noreferrer"}},[t._v("块引用"),e("OutboundLink")],1),t._v("的规范也默许了这个原则。) 这个原则意味着如果")]),t._v(" "),e("pre",[e("code",[t._v("  * I need to buy\n    - new shoes\n    - a coat\n    - a plane ticket\n")])]),t._v(" "),e("p",[t._v("是一个列表项，其中包含一个段落后跟一个嵌套的子列表，因为所有 Markdown 实现都是这样解析的（尽管该段落可能没有"),e("code",[t._v("<p>")]),t._v("标签，因为列表「稠密」），然后")]),t._v(" "),e("pre",[e("code",[t._v("I need to buy\n- new shoes\n- a coat\n- a plane ticket\n")])]),t._v(" "),e("p",[t._v("本身应该是一个段落，后跟一个嵌套的子列表。"),e("br"),t._v("\n由于 Markdown 实现允许列表中断列表项内的段落，因此"),e("a",{attrs:{href:"https://github.github.com/gfm/#principle-of-uniformity",target:"_blank",rel:"noopener noreferrer"}},[t._v("统一性原则"),e("OutboundLink")],1),t._v("要求我们允许这个外部列表项。 （"),e("a",{attrs:{href:"http://docutils.sourceforge.net/rst.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("reStructuredText"),e("OutboundLink")],1),t._v("采用不同的方法，在列表之前甚至在其他列表项中也需要空行。）"),e("br"),t._v("\n为了解决带有嵌套数字的段落中出现意外的列表，我们只允许以 1 开头的列表来中断段落。 从而，"),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("我们也可能获得一个未缩进像这样的结果"),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("但是这应该可以防止大多数意外的列表生成。"),e("br"),t._v("\n项之间可以有任意行的空行："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),e("p",[t._v("为了要分隔相同类型的连续列表，或者分隔列表与缩进的代码块，不然的话这些代码块将被解析为最终列表项的子段，可以通过插入空白的 HTML 注释："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),e("p",[t._v("列表项不需要缩进到同一级别。 以下列表项将被视为同一列表级别的项目，因为没有缩进到足以属于上一个列表项："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),e("p",[t._v("但请注意，列表项可能不会缩进三个以上的空格。在这里 "),e("code",[t._v("- e")]),t._v(" 被视为段落延续行，因为它缩进了三个以上的空格："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("这里的 "),e("code",[t._v("3. c")]),t._v(" 被视为缩进的代码块，因为它缩进了四个空格且前面有一行空行。"),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("这是一个稀疏列表，因为列表项被空行分隔："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("像这样，有一个空的列表项："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("这些是稀疏列表，尽管项中间没有空隔，但是其中一项中含有被空行分隔的两个块级元素："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),e("p",[t._v("这是一个稠密列表，因为空行存在于代码块中："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("这个列表是稠密的，因为空行是子列表的两个段落中间的，所以子列表是稀疏的，外部列表是稠密的："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("这个列表是稠密的，因为空行包含在块引用中："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("这个列表是稠密的，因为连续的块元素没有被空行分割："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("一个单个段落是稠密的："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}}),t._v(" "),e("p",[t._v("这个列表是稀疏的，因为列表项中含有被空行分隔块元素："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("p",[t._v("这里的外部列表是稀疏的，内部列表是稠密的："),e("br"),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1),t._v(" "),e("Example",{attrs:{index:t.$page.frontmatter.start++}})],1)},[],!1,null,null,null);r.default=n.exports}}]);